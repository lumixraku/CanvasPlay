<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body {
      margin: 0;
    }
  </style>
</head>

<body>
  <canvas id="myCanvas" width="800" height="800"></canvas>
  <canvas id="myCanvasRuler" width="800" height="800"
    style="position: absolute; top: 0; left:0; z-index: 10;pointer-events: none;"></canvas>
  <canvas id="myCanvasMouse" width="800" height="800"
    style="position: absolute; top: 0; left:0; z-index: 10;pointer-events: none;"></canvas>
  <script type="module">
    import { DOMMatrix as DOMMatrix3rd } from '../matrix/domMatrix.mjs';
    const dpr = window.devicePixelRatio;

    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');
    window.ctx = ctx;
    const myCanvasMouse = document.getElementById('myCanvasMouse');
    const ctxMouse = myCanvasMouse.getContext('2d');
    const myCanvasRuler = document.getElementById('myCanvasRuler');
    const ctxRuler = myCanvasRuler.getContext('2d');
    // ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    const ctxTrans = ctx.getTransform();


    // 设置 canvas 大小
    canvas.width = 800;
    canvas.height = 800;

    const numBlocksX = 8;
    const numBlocksY = 8;
    const colorMap = {}

    const viewportPos = window.viewportPos = { x: -50, y: 50 } // 

    function toFixed2(number) {
      return Math.round(number * 100) / 100;
    }

    function genColorMap() {
      for (let x = 0; x < numBlocksX; x++) {
        colorMap[x] = {}
        for (let y = 0; y < numBlocksY; y++) {

          // 生成一个随机的冷色色值
          const hue = Math.floor(Math.random() * 180); // 0-180 是冷色范围
          const saturation = 50 + Math.floor(Math.random() * 50); // 50-100 饱和度
          const lightness = 50 + Math.floor(Math.random() * 50); // 50-100 亮度
          const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
          colorMap[x][y] = color;
        }
      }
    }

    function drawTiles(ctx) {
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();

      ctx.save();
      // 定义色块的尺寸
      const blockSize = 100;


      // 遍历绘制每个色块
      for (let x = 0; x < numBlocksX; x++) {
        for (let y = 0; y < numBlocksY; y++) {
          // 计算当前色块的起始坐标
          const left = x * blockSize;
          const top = y * blockSize;



          // 绘制当前色块
          ctx.fillStyle = colorMap[x][y];
          ctx.fillRect(left, top, blockSize, blockSize);
          ctx.fillRect(left, top, blockSize, blockSize);
        }
      }
      ctx.restore();
    }

    function drawRuler(ctxRuler) {
      ctxRuler.save();
      ctxRuler.setTransform(1, 0, 0, 1, 0, 0);
      ctxRuler.clearRect(0, 0, canvas.width, canvas.height);
      ctxRuler.restore();

      const canvasWidth = canvas.width;
      const canvasHeight = canvas.height;
      const step = 100;
      const smallTickLength = 10;
      const largeTickLength = 20;
      const textPosY = 30;
      const textPosX = 30;
      const textHeight = 15;


      const m = ctx.getTransform();
      // 绘制标尺 X 轴
      ctxRuler.save();
      ctxRuler.setTransform(m.a, m.b, m.c, m.d, m.e, 0);
      ctxRuler.textAlign = 'center';
      for (let i = 0; i <= canvasWidth; i += step) {
        // 绘制长竖线
        ctxRuler.beginPath();
        ctxRuler.moveTo(i, 0);
        ctxRuler.lineTo(i, largeTickLength);
        ctxRuler.stroke();

        // 绘制数字
        if (i % step === 0) {
          ctxRuler.font = '12px Arial';
          ctxRuler.fillText(i.toString(), i, textPosY);
        }

        // 绘制短竖线
        for (let j = 10; j < step; j += 10) {
          ctxRuler.beginPath();
          ctxRuler.moveTo(i + j, 0);
          ctxRuler.lineTo(i + j, smallTickLength);
          ctxRuler.stroke();

          if (j == 50) {
            ctxRuler.font = '10px Arial';
            ctxRuler.fillText((i + 50).toString(), i + j, textPosY - 10);
          }
        }
      }
      ctxRuler.restore();

      // 绘制标尺 Y 轴
      ctxRuler.save();
      ctxRuler.setTransform(m.a, m.b, m.c, m.d, 0, m.f);
      for (let i = 0; i <= canvasHeight; i += step) {
        // 绘制长横线
        ctxRuler.beginPath();
        ctxRuler.moveTo(0, i);
        ctxRuler.lineTo(largeTickLength, i);
        ctxRuler.stroke();

        // 绘制数字
        if (i % step === 0) {
          ctxRuler.font = '12px Arial';
          ctxRuler.fillText(i.toString(), textPosX, i + 5);
        }

        // 绘制短横线
        for (let j = 10; j < step; j += 10) {
          ctxRuler.beginPath();
          ctxRuler.moveTo(0, i + j);
          ctxRuler.lineTo(smallTickLength, i + j);
          ctxRuler.stroke();

          if (j == 50) {
            ctxRuler.font = '10px Arial';
            ctxRuler.fillText((i + 50).toString(), textPosY - 10, i + j + 5);
          }
        }
      }
      ctxRuler.restore();
    }

    function drawAll() {
      drawTiles(ctx);
      drawRuler(ctxRuler)
    }

    // test1, use inverse matrix go back to origin transform
    function inverseDemo() {
      console.log('before', ctx.getTransform());
      ctx.translate(-50, -50);
      ctx.scale(1.3, 1.3);
      const trans = ctx.getTransform();
      const inverse = trans.inverse();
      ctx.transform(toFixed2(inverse.a),
        toFixed2(inverse.b),
        toFixed2(inverse.c),
        toFixed2(inverse.d),
        toFixed2(inverse.e),
        toFixed2(inverse.f));
      console.log('after', ctx.getTransform());
      drawTiles(ctx);
    }

    // 坐标系变换
    function transformCoord() {
      ctx.save();
      ctx.translate(-50, 50);
      ctx.scale(2, 2);
      ctxMouse.translate(-50, 50);
      ctxMouse.scale(2, 2);
      drawTiles(ctx);
      drawRuler(ctx);
      ctx.restore();
      const trans = ctx.getTransform();
      const inverse = trans.inverse();
      canvas.addEventListener('pointermove', e => {

        const x = e.clientX - canvas.getBoundingClientRect().left;
        const y = e.clientY - canvas.getBoundingClientRect().top;
        // 当前坐标系（浏览器 canvas 坐标系）换算为 trans 的坐标系上的点
        const pos = inverse.transformPoint({ x, y });
        window.pos = pos;
        ctxMouse.clearRect(0, 0, canvas.width, canvas.height);
        ctxMouse.fillStyle = 'red';
        ctxMouse.fillRect(pos.x - 5, pos.y - 5, 10, 10);
        ctxMouse.fillText(`${Math.round(pos.x)}, ${Math.round(pos.y)}`, pos.x, pos.y - 10)
      })

    }


    function transformCoordWith3rdPartyMatrix() {
      ctx.translate(-50, 50);
      ctx.scale(2, 2);
      ctxMouse.translate(-50, 50);
      ctxMouse.scale(2, 2);
      drawTiles(ctx);
      drawRuler(ctx);
      const arr = ctx.getTransform().toFloat32Array();
      const trans = DOMMatrix.fromFloat32Array(arr);
      const inverse = trans.inverse();
      canvas.addEventListener('pointermove', e => {

        const x = e.clientX - canvas.getBoundingClientRect().left;
        const y = e.clientY - canvas.getBoundingClientRect().top;
        // 当前坐标系（浏览器 canvas 坐标系）换算为 trans 的坐标系上的点
        const pos = inverse.transformPoint({ x, y, z: 0, w: 1 });
        window.pos = pos;
        ctxMouse.clearRect(0, 0, canvas.width, canvas.height);
        ctxMouse.fillStyle = 'red';
        ctxMouse.fillRect(pos.x - 2, pos.y - 2, 4, 4);
        ctxMouse.fillText(`${Math.round(pos.x)}, ${Math.round(pos.y)}`, pos.x, pos.y - 10)
      })
    }

    function drawCursor(pos) {
      window.pos = pos;

      ctxMouse.save();
      ctxMouse.setTransform(1, 0, 0, 1, 0, 0);
      ctxMouse.clearRect(0, 0, canvas.width, canvas.height);
      ctxMouse.restore();
      const m = ctx.getTransform();
      ctxMouse.setTransform(m);
      ctxMouse.fillStyle = 'red';
      ctxMouse.fillRect(pos.x - 5, pos.y - 5, 10, 10);
      ctxMouse.fillText(`${Math.round(pos.x)}, ${Math.round(pos.y)}`, pos.x, pos.y - 10);
    }

    function bindEvent() {
      let originPos = { x: 0, y: 0 };
      let pointerdownAndMoving = 0;
      let lastPos = { x: 0, y: 0 };
      let pointerIsDown = 0;
      let delta = { x: 0, y: 0 };

      let posWhenPointerdown = { x: 0, y: 0 };
      let transWhenPointerDown;


      const updateCursor = (e) => {
        const x = e.clientX - canvas.getBoundingClientRect().left;
        const y = e.clientY - canvas.getBoundingClientRect().top;
        const trans = ctx.getTransform();
        const inverse = trans.inverse();
        const pos = inverse.transformPoint({ x, y });
        drawCursor(pos);
      }

      const dragCanvasByPointerEvent = (e) => {
        if (e.type === 'pointermove') {
          if (!pointerIsDown) return;
          pointerdownAndMoving = 1;
        }

        const offsetX = e.clientX - canvas.getBoundingClientRect().left;
        const offsetY = e.clientY - canvas.getBoundingClientRect().top;

        const curPos = { x: offsetX, y: offsetY };
        delta = { x: curPos.x - lastPos.x, y: curPos.y - lastPos.y }

        lastPos.x = curPos.x;
        lastPos.y = curPos.y;

        const deltaFromPointerdown = { x: curPos.x - posWhenPointerdown.x, y: curPos.y - posWhenPointerdown.y }
        // const m = DOMMatrix.fromMatrix(transWhenPointerDown);
        const m = DOMMatrix3rd.fromFloat32Array(transWhenPointerDown.toFloat32Array())

        m.e += deltaFromPointerdown.x;
        m.f += deltaFromPointerdown.y;
        ctx.setTransform(m);
        viewportPos.x = m.e / m.a;
        viewportPos.y = m.f / m.d;
        // console.log('get translate', ctx.getTransform().e)

        drawAll();
      }

      const dragCanvasByWheelEvent = (e) => {
        const deltaX = -e.deltaX;
        const deltaY = -e.deltaY;
        const m = ctx.getTransform();
        // const setM = DOMMatrix.fromMatrix(m);
        const setM = DOMMatrix3rd.fromFloat32Array(m.toFloat32Array())
        setM.e = m.e + deltaX;
        setM.f = m.f + deltaY;
        ctx.setTransform(setM);
        viewportPos.x = setM.e / setM.a;
        viewportPos.y = setM.f / setM.d;
        drawAll();

      };

      const cancelMoving = () => {
        pointerIsDown = false;
        pointerdownAndMoving = 0;
      }

      canvas.addEventListener('pointerdown', e => {
        pointerIsDown = true;
        const offsetX = e.clientX - canvas.getBoundingClientRect().left;
        const offsetY = e.clientY - canvas.getBoundingClientRect().top;
        posWhenPointerdown = { x: offsetX, y: offsetY }

        transWhenPointerDown = ctx.getTransform();
      })

      // cursor pos
      canvas.addEventListener('pointermove', e => {
        // if(pointerIsDown) return;
        updateCursor(e);
      })

      // drag event
      canvas.addEventListener('pointermove', e => {
        dragCanvasByPointerEvent(e);
      });


      canvas.addEventListener('pointerup', e => {
        cancelMoving();
      });

      canvas.addEventListener('pointercancel', e => {
        cancelMoving();
      });

      canvas.addEventListener('pointerleave', e => {
        cancelMoving();
      });
      canvas.addEventListener('pointerout', e => {
        cancelMoving();
      });

      canvas.addEventListener('wheel', e => {
        dragCanvasByWheelEvent(e);
        updateCursor(e);
        e.stopPropagation();
        e.preventDefault();
      });
    }


    function initDraw() {
      ctx.save();
      ctx.scale(2, 2);
      ctx.translate(viewportPos.x, viewportPos.y);
      const m = ctx.getTransform();
      ctxMouse.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);
      drawAll();
    }
    genColorMap();
    bindEvent();

    initDraw()
    // transformCoord();
    // transformCoordWith3rdPartyMatrix();    
  </script>
</body>

</html>