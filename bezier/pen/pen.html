<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        canvas {
            width: 100%;
            height: 900px;
            border: 1px solid #ccc;
        }
    </style>
    <title>Document</title>
    <script src="/public/paper-full.js"></script>
</head>

<body>
    <canvas id="myCanvas"></canvas>    
    <script type="module">
        import { existsSamePoint } from './util.mjs';
        paper.setup('myCanvas');

        const recKeyPoints = [];
        let startPoint = null; // 记录点击位置的起点
        let endPoint = null;




        let drewLines = [];
        let currCertainLine = null; //new paper.Path();;
        let clickExist = false;
        let drawing = false;
        let isDragging = false; // drag 松开时, cp 确定, 更新端点

        // 当前的 controlPoint
        let cp1, cp2, cp1HandleLine, cp2HandleLine;
        // click & drag 
        {

            // 监听鼠标点击事件
            function onMouseDown(event) {
                drawing = true;
                let newStart = false;
                if(!startPoint) {
                    newStart = true;
                    currCertainLine = startNewLine(event);
                    putAPoint(event.point);
                }

                if (newStart) {
                    drawASmallCircle(event.point);
                }
            }



            function onMouseMove(event) {
                if (!drawing) return;
                // endPoint s= event.point; // 更新终点位置
                updateLastPoint(event);
            }


            // 监听鼠标拖拽事件
            function onMouseDrag(event) {
                if (!drawing) return;

                const lastSeg = getLastSegmentOfCurrLine();
                if(!isDragging) {
                    // 创建 controlPoint
                    let control = createControlPoint(lastSeg);
                    cp1 = control.cp1;
                    cp2 = control.cp2;
                    cp1HandleLine = control.cp1HandleLine;
                    cp2HandleLine = control.cp2HandleLine;
                }
                updateControlPoint(event, lastSeg, {cp1, cp2, cp1HandleLine, cp2HandleLine});
                isDragging = true;
            }

            // 监听鼠标Up事件
            // 新一轮的开始
            function onMouseUp(event) {
                // 绘制一个点
                let rawPoint = new paper.Point(event.point.x, event.point.y);
                let point = rawPoint;
                let samePoint = existsSamePoint(recKeyPoints, point);

                // end of curr line
                let isSamePoint = false;
                if (samePoint) {
                    point = samePoint;
                    isSamePoint = true;
                } else {
                    putAPoint(point, isSamePoint);
                }



                // if (samePoint) {
                //     endOfDraw();
                // }

            }

            // 监听键盘按下事件
            function onKeyDown(event) {
                if (event.key === 'escape') {
                    // 在按下ESC键时执行的操作
                    console.log('ESC键按下了');
                    drawing = false;
                    endPoint = startPoint;
                    endOfDraw();
                }
            }

            function onMouseClick(event) {
                // debugger
                // isBezierMode = false;
            }


            function endOfDraw() {
                drawing = false;
                startPoint = null;
                drewLines.push(currCertainLine)
                // currCertainLine = null;
            }


            // 绑定事件处理程序
            paper.view.onMouseDown = onMouseDown;
            paper.view.onMouseDrag = onMouseDrag;
            paper.view.onMouseMove = onMouseMove;
            paper.view.onMouseUp = onMouseUp;
            paper.view.onClick = onMouseClick;
            paper.view.onKeyDown = onKeyDown;

            function startNewLine(event) {

                let currCertainLine = new paper.Path();
                currCertainLine.strokeColor = 'black';

                return currCertainLine;
            }

            function updateControlPoint(event, seg, { cp1, cp2, cp1HandleLine, cp2HandleLine }) {
                const pointOfSeg = seg.point;
                const eventPoint = event.point;
                cp1.position = eventPoint;
                const delta = eventPoint.subtract(pointOfSeg);
                cp2.position = pointOfSeg.subtract(delta);
                seg.handleIn = cp2.position.subtract(pointOfSeg);
                cp1HandleLine.segments[0].point = pointOfSeg;
                cp1HandleLine.segments[1].point = cp1.position;
                cp2HandleLine.segments[0].point = pointOfSeg;
                cp2HandleLine.segments[1].point = cp2.position;                               
            }

            function createControlPoint(seg) {

                let cp1HandleLine = new paper.Path();
                let cp2HandleLine = new paper.Path();
                let cp2 = new paper.Path.Circle(new paper.Point(-10, -10), 5);
                let cp1 = new paper.Path.Circle(new paper.Point(-10, -10), 5);
                cp1.fillColor = 'blue';
                cp2.fillColor = 'blue';
                cp1HandleLine.strokeColor = 'grey';
                cp1HandleLine.dashArray = [5, 5]; // 设置虚线样式    
                cp2HandleLine.strokeColor = 'grey';
                cp2HandleLine.dashArray = [5, 5]; // 设置虚线样式    
                cp1HandleLine.add([-10, -10], [-10, -10]);
                cp2HandleLine.add([-10, -10], [-10, -10]);

                cp1.on('mousedown', function(event) {
                    event.stopPropagation();
                });
                cp1.on('mouseup', function (event) {
                    event.stopPropagation();
                    isDragging = false;
                    let lastSeg = getLastSegmentOfCurrLine();
                    lastSeg.handleOut = cp1.position.subtract(lastSeg.point);
                    if(drawing){
                        currCertainLine.add(event.point);  // 作为当前曲线的末端点                    
                    }
                    
                });                
                cp1.on('mousedrag', function (event) {
                    event.stopPropagation();
                    cp1.position = cp1.position.add(event.delta);
                    cp1HandleLine.segments[1].point = cp1.position;
                    seg.handleOut = cp1.position.subtract(seg.point);
                });

                cp2.on('mousedown', function (event) {
                    event.stopPropagation();
                });
                cp2.on('mouseup', function (event) {
                    event.stopPropagation();
                    isDragging = false;
                    let lastSeg = getLastSegmentOfCurrLine();
                    lastSeg.handleOut = cp2.position.subtract(lastSeg.point);
                    if (drawing) {
                        currCertainLine.add(event.point);  // 作为当前曲线的末端点                    
                    }
                });
                cp2.on('mousedrag', function (event) {
                    event.stopPropagation();
                    cp2.position = cp2.position.add(event.delta);
                    cp2HandleLine.segments[1].point = cp2.position;
                    seg.handleIn = cp2.position.subtract(seg.point);
                });                

                return { cp1HandleLine , cp2HandleLine, cp1, cp2 }
                
            }


            function drawASmallCircle(point) {
                const pointShape = new paper.Path.Circle(point, 5);
                pointShape.fillColor = 'black';
                return pointShape;
            }

            function putAPoint(point, isSamePoint) {
                startPoint = point;
                endPoint = point;

                currCertainLine.add(point);
                const pointIdx = Math.max(0, currCertainLine.segments.length - 1);
                recKeyPoints.push(point);

                let pointShape;
                if (!isSamePoint) {
                    pointShape = new paper.Path.Circle(point, 5);
                    pointShape.fillColor = 'black';
                }
            }

            function updateLastPoint(event) {
                // 更新点的位置
                const lastSeg = getLastSegmentOfCurrLine();
                lastSeg.point = event.point;
            }

            function getLastSegmentOfCurrLine() {
                let lastOne = Math.max(0, currCertainLine.segments.length - 1);
                return currCertainLine.segments[lastOne];

            }

            // function updateCurve(event) {
            //     const eventPoint = event.point;
            //     const lastSeg = getLastSegmentOfCurrLine();
            //     const lastPoint = lastSeg.point;
            //     if (currCertainLine) {
            //         lastSeg.point = eventPoint;
            //     }
            // }

        }
    </script>
</body>

</html>