<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        canvas {
            width: 100%;
            height: 900px;
            border: 1px solid #ccc;
        }
    </style>
    <title>Document</title>
    <script src="/public/paper-full.js"></script>
</head>

<body>
    <canvas id="myCanvas"></canvas>    
    <script type="module">
        import { existsSamePoint } from './util.mjs';
        paper.setup('myCanvas');

        const recKeyPoints = [];
        let startPoint = null; // 记录点击位置的起点
        let endPoint = null;



        let cp1HandleLine = new paper.Path();
        let cp2HandleLine = new paper.Path();
        let cp2 = new paper.Path.Circle(new paper.Point(-10, -10), 5);
        let cp1 = new paper.Path.Circle(new paper.Point(-10, -10), 5);
        cp1.fillColor = 'blue';
        cp2.fillColor = 'blue';
        cp1HandleLine.strokeColor = 'grey';
        cp1HandleLine.dashArray = [5, 5]; // 设置虚线样式    
        cp2HandleLine.strokeColor = 'grey';
        cp2HandleLine.dashArray = [5, 5]; // 设置虚线样式    
        cp1HandleLine.add([-10, -10], [-10, -10]);
        cp2HandleLine.add([-10, -10], [-10, -10]);


        let fixedLines = [];
        let currCertainLine = null; //new paper.Path();;
        let clickExist = false;
        let drawing = false;
        let isDragging = false; // drag 松开时, cp 确定, 更新端点
        // click & drag 
        {

            // 监听鼠标点击事件
            function onMouseDown(event) {
                drawing = true;

                const newStart = startNewLineIfNoStartPoint(event);



                // 绘制一个点
                let rawPoint = new paper.Point(event.point.x, event.point.y);
                let point = rawPoint;
                let samePoint = existsSamePoint(recKeyPoints, point);

                // end of curr line
                let isSamePoint = false;
                if (samePoint) {
                    point = samePoint;
                    isSamePoint = true;
                }

                if (newStart) {
                    drawAPoint(point);
                } else {
                    // putAPoint(point, isSamePoint);
                }
            }



            function onMouseMove(event) {
                if (!drawing) return;
                // endPoint s= event.point; // 更新终点位置
                updateLastPoint(event);
            }


            // 监听鼠标拖拽事件
            function onMouseDrag(event) {
                if (!drawing) return;
                isDragging = true;
                updateControlPoint(event);
            }

            // 监听鼠标Up事件
            // 新一轮的开始
            function onMouseUp(event) {
                // 绘制一个点
                let rawPoint = new paper.Point(event.point.x, event.point.y);
                let point = rawPoint;
                let samePoint = existsSamePoint(recKeyPoints, point);

                // end of curr line
                let isSamePoint = false;
                if (samePoint) {
                    point = samePoint;
                    isSamePoint = true;
                }

                if (isDragging) {
                    isDragging = false;
                    let lastSeg = getLastSegmentOfCurrLine();
                    lastSeg.handleOut = cp1.position.subtract(lastSeg.point);
                    currCertainLine.add(point);
                }
                else {
                    putAPoint(point, isSamePoint);
                }

                if (samePoint) {
                    drawing = false;
                    currCertainLine = null;
                }

            }

            // 监听键盘按下事件
            function onKeyDown(event) {
                if (event.key === 'escape') {
                    // 在按下ESC键时执行的操作
                    console.log('ESC键按下了');
                    drawing = false;
                    endPoint = startPoint;
                    endOfDraw();
                }
            }

            function onMouseClick(event) {
                // debugger
                // isBezierMode = false;
            }


            function endOfDraw() {
                fixedLines.push(currCertainLine)
                drawing = false;
                currCertainLine = null;
            }


            // 绑定事件处理程序
            paper.view.onMouseDown = onMouseDown;
            paper.view.onMouseDrag = onMouseDrag;
            paper.view.onMouseMove = onMouseMove;
            paper.view.onMouseUp = onMouseUp;
            paper.view.onClick = onMouseClick;
            paper.view.onKeyDown = onKeyDown;

            function startNewLineIfNoStartPoint(event) {

                if (!currCertainLine) {
                    currCertainLine = new paper.Path();
                    currCertainLine.strokeColor = 'black';
                    window.currCertainLine = currCertainLine;

                    putAPoint(event.point);

                    currCertainLine.add(event.point);
                    return true;
                }
                return false;
            }

            function updateControlPoint(event) {
                const lastSeg = getLastSegmentOfCurrLine();
                const lastPointInLine = lastSeg.point;
                const eventPoint = event.point;
                cp1.position = eventPoint;
                const delta = eventPoint.subtract(lastPointInLine);
                cp2.position = lastPointInLine.subtract(delta);
                lastSeg.handleIn = cp2.position.subtract(lastPointInLine);
                cp1HandleLine.segments[0].point = lastPointInLine;
                cp1HandleLine.segments[1].point = cp1.position;
                cp2HandleLine.segments[0].point = lastPointInLine;
                cp2HandleLine.segments[1].point = cp2.position;                
                // if (currCertainLine) {
                //     let lastOne = currCertainLine.segments.length - 1;
                //     if (currCertainLine._segments.length > 1) {
                //         const lastPoint = currCertainLine.segments[lastOne].point;
                //         // 以事件的点, 中心对称点作为控制点
                //         currCertainLine.segments[lastOne].handleIn = cp1.position.subtract(lastPoint);
                //     }
                // }                
            }


            function drawAPoint(point) {
                const pointShape = new paper.Path.Circle(point, 5);
                pointShape.fillColor = 'black';
            }

            function putAPoint(point, isSamePoint) {
                startPoint = point;
                endPoint = point;

                currCertainLine.add(point);
                const pointIdx = Math.max(0, currCertainLine.segments.length - 1);
                recKeyPoints.push(point);

                let pointShape;
                if (!isSamePoint) {
                    pointShape = new paper.Path.Circle(point, 5);
                    pointShape.fillColor = 'black';
                }
            }

            function updateLastPoint(event) {
                // 更新点的位置
                const lastSeg = getLastSegmentOfCurrLine();
                lastSeg.point = event.point;
            }

            function getLastSegmentOfCurrLine() {
                let lastOne = Math.max(0, currCertainLine.segments.length - 1);
                return currCertainLine.segments[lastOne];

            }

            // function updateCurve(event) {
            //     const eventPoint = event.point;
            //     const lastSeg = getLastSegmentOfCurrLine();
            //     const lastPoint = lastSeg.point;
            //     if (currCertainLine) {
            //         lastSeg.point = eventPoint;
            //     }
            // }

        }
    </script>
</body>

</html>