<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            width: 100%;
            height: 400px;
            border: 1px solid #ccc;
        }
    </style>
    <script src="/public/paper-full.js"></script>
</head>

<body>
    <canvas id="myCanvas"></canvas>
    <script>


        paper.install(window);
        window.onload = function () {
            paper.setup('myCanvas');

            // Define the start and end points of the curve
            var startPoint = new Point(100, 150);
            var endPoint = new Point(400, 150);

            // Define the control points
            var controlPoint1 = new Point(150, 50);
            var controlPoint2 = new Point(350, 250);

            var handleLine1 = new paper.Path({
                segments: [startPoint, controlPoint1],
                strokeColor: 'red',
                dashArray: [4, 4]
            });
            var handleLine2 = new paper.Path({
                segments: [endPoint, controlPoint2],
                strokeColor: 'red',
                dashArray: [4, 4]
            });
            // Create path for the bezier curve
            // 初始化时, Segments [Point] 的主要部分是一个点，表示曲线开始点 or 结束点。
            // 每一个起点都有 handleIn  每一个结束点都有 handleOut 

            // HandleIn: 一个向量，是控制点和开始点构成的向量, controlPoint - startPoint 它定义了曲线接近控制点时的形状。
            // HandleOut: 一个向量，是控制点和结束点构成的向量, controlPoint - endPoint 它定义了曲线远离控制点的形状。
            var bezierPath = new Path({
                segments: [startPoint, endPoint],
                // segments: [startPoint, controlPoint1, controlPoint2, endPoint],
                strokeColor: 'black'
            });

            // Set the control handles for the curve
            // PS! bezierPath.segments[0] is a segment, not startPoint (个人觉得这个 Path 初始化的参数有点歧义)
            bezierPath.segments[0].handleOut = controlPoint1.subtract(startPoint);
            bezierPath.segments[1].handleIn = controlPoint2.subtract(endPoint);

            // Create draggable handles for the control points
            function createHandle(point, handleLine, color) {
                var handle = new Path.Circle({
                    center: point,
                    radius: 8,
                    fillColor: color || 'red'
                });
                handle.draggable = true;
                handle.on('mousedrag', function (event) {
                    handle.position = handle.position.add(event.delta);
                    // controlPoint1.position = handle.position;
                    handleLine && (handleLine.segments[1].point = handle.position);
                    updateCurve();
                });
                return handle;
            }

            function createEndPoint(point, handleLine, color) {
                var handle = new Path.Circle({
                    center: point,
                    radius: 8,
                    fillColor: color || 'red'
                });
                handle.draggable = true;
                handle.on('mousedrag', function (event) {
                    handle.position = handle.position.add(event.delta);
                    // controlPoint1.position = handle.position;
                    handleLine && (handleLine.segments[0].point = handle.position);
                    updateCurve();
                });
                return handle;
            }

            var handleForControl1 = createHandle(controlPoint1, handleLine1);
            var handleForControl2 = createHandle(controlPoint2, handleLine2);

            var handleForStartPoint = createEndPoint(startPoint, handleLine1, 'blue');
            var handleForEndPoint = createEndPoint(endPoint, handleLine2, 'blue');
            // Function to update the bezier curve based on handles' positions
            function updateCurve() {
                // 更新 startPoint 位置
                bezierPath.segments[0].point = handleForStartPoint.position;
                // 更新 endPoint 位置
                bezierPath.segments[1].point = handleForEndPoint.position;
                // 更新第一个控制点位置
                bezierPath.segments[0].handleOut = handleForControl1.position.subtract(bezierPath.segments[0].point);
                // 更新第二个控制点位置
                bezierPath.segments[1].handleIn = handleForControl2.position.subtract(bezierPath.segments[1].point);


            }

            // Initial update of the curve
            updateCurve();
        }
    </script>
</body>

</html>