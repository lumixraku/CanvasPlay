<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script type="importmap">
{
  "imports": {
    "pixi.js": "https://cdn.skypack.dev/pixi.js@6.1.3"
  }
}
</script>

    <script type="module">
        import { Application, Sprite } from 'pixi.js';
        import * as PIXI from 'pixi.js';


        // 创建舞台和渲染器
        const app = new PIXI.Application({ width: 800, height: 600 });
        document.body.appendChild(app.view);





        // 创建矩形对象
        const rectangle = new PIXI.Graphics();
        app.stage.addChild(rectangle);

        // 定义矩形的四个顶点坐标（顺时针或逆时针方向）
        const P1 = new PIXI.Point(100, 100);
        const P2 = new PIXI.Point(300, 100);
        const P3 = new PIXI.Point(300, 200);
        const P4 = new PIXI.Point(100, 200);
        const centerX = P1.x + (P2.x - P1.x)/2;
        const centerY = P2.y + (P3.y - P2.y) / 2;
        const rectPoints = [P1, P2, P3, P4];
        // 绘制旋转后的矩形
        rectangle.beginFill(0x00FF00); // 使用绿色填充
        rectangle.moveTo(P1.x, P1.y);
        rectangle.lineTo(P2.x, P2.y);
        rectangle.lineTo(P3.x, P3.y);
        rectangle.lineTo(P4.x, P4.y);
        rectangle.lineTo(P1.x, P1.y);
        rectangle.endFill();

        // 创建矩阵并进行旋转
        const matrix = new PIXI.Matrix();
        const angle = 45;
        const radians = angle * Math.PI / 180;        
        // matrix.rotate(45 * Math.PI / 180); // 将矩阵以左上角旋转45度（以弧度为单位）
        // 围绕中心点旋转
        matrix.translate(-centerX, -centerY);
        matrix.rotate(radians);
        matrix.translate(centerX, centerY);
        
        // 应用矩阵变换
        rectangle.transform.setFromMatrix(matrix);


        const graphics = new PIXI.Graphics();
        app.stage.addChild(graphics);


        // 判断点 P 是否在未旋转的矩形内的函数
        function isPointInRectangle(point, rectPoints) {
            const [p1, p2, p3, p4] = rectPoints;

            const minX = Math.min(p1.x, p2.x, p3.x, p4.x);
            const maxX = Math.max(p1.x, p2.x, p3.x, p4.x);
            const minY = Math.min(p1.y, p2.y, p3.y, p4.y);
            const maxY = Math.max(p1.y, p2.y, p3.y, p4.y);

            return point.x >= minX && point.x <= maxX && point.y >= minY && point.y <= maxY;
        }


        {
            app.view.addEventListener('mousemove', onMouseMove);

            function onMouseMove(event) {
                // 获取鼠标在舞台上的坐标
                const mousePosition = app.renderer.plugins.interaction.mouse.global;

                // 清空图形对象
                graphics.clear();

                // 设置绘制属性
                const radius = 5; // 点的半径
                const color = 0xFF0000; // 点的颜色

                // 判断点 P 的坐标
                const pointP = new PIXI.Point(mousePosition.x, mousePosition.y);
                // const pointP = new PIXI.Point(50, 60);
                
                // 绘制圆形的点
                graphics.beginFill(color);
                graphics.drawCircle(pointP.x, pointP.y, radius);
                graphics.endFill();



                // 使用矩阵的 apply 方法将点 P 的坐标应用矩阵变换
                const transformedP = matrix.applyInverse(pointP);

                // 判断点 P 是否在未旋转的矩形内
                const isPointInside = isPointInRectangle(transformedP, rectPoints);

                // 输出判断结果
                console.log(isPointInside, mousePosition.x, mousePosition.y);

                // 渲染舞台
                app.renderer.render(app.stage);
            }
        }

        // 将应用程序渲染到页面中
        document.body.appendChild(app.view);
    </script>
</body>

</html>