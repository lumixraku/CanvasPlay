<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    html,
    body,
    canvas {
      margin: 0;
      width: 100%;
      height: 100%;
    }

    p {
      text-align: center;
    }
  </style>
</head>

<body>
  <canvas id="cnv" width="800" height="600"></canvas>

  <p>Created by Jérémy Heleine for <a href="https://codepen.io/SitePoint/pen/obapXL">CodePen</a></p>


  https://juejin.im/entry/5aac7d90518825556918c0b7
  <script>

    var Vertex = function (x, y, z) {
      this.x = parseFloat(x);
      this.y = parseFloat(y);
      this.z = parseFloat(z);
    };

    var Vertex2D = function (x, y) {
      this.x = parseFloat(x);
      this.y = parseFloat(y);
    };

    var Cube = function (center, side) {
      //
      // Generate the vertices
      // side 是立方体边长  目前边长设定的是屏幕高度的一半
      var d = side / 2;


      // 默认看起来这里的 z 表示的是纵向  why!!!
      // 后来我调整为了右手坐标系
      this.vertices = [
        //近面左下
        new Vertex(center.x - d, center.y - d, center.z + d),

        new Vertex(center.x - d, center.y - d, center.z - d),
        new Vertex(center.x + d, center.y - d, center.z - d),
        new Vertex(center.x + d, center.y - d, center.z + d),
        new Vertex(center.x + d, center.y + d, center.z + d),
        new Vertex(center.x + d, center.y + d, center.z - d),
        new Vertex(center.x - d, center.y + d, center.z - d),
        new Vertex(center.x - d, center.y + d, center.z + d)
      ];
      console.log("vectices", this.vertices)

      // Generate the faces
      this.faces = [
        [this.vertices[0], this.vertices[1], this.vertices[2], this.vertices[3]],
        [this.vertices[3], this.vertices[2], this.vertices[5], this.vertices[4]],
        [this.vertices[4], this.vertices[5], this.vertices[6], this.vertices[7]],
        [this.vertices[7], this.vertices[6], this.vertices[1], this.vertices[0]],
        [this.vertices[7], this.vertices[0], this.vertices[3], this.vertices[4]],
        [this.vertices[1], this.vertices[6], this.vertices[5], this.vertices[2]]
      ];
    };

    function project(M) {
      return new Vertex2D(M.x, M.y);
    }

    function render(objects, ctx, dx, dy) {
      // Clear the previous frame
      ctx.clearRect(0, 0, 2 * dx, 2 * dy);

      // dx  dy 是定值 (屏幕宽高的一半) 所以 (dx, dy) 就是屏幕的中心位置

      // For each object
      for (var i = 0, n_obj = objects.length; i < n_obj; ++i) {
        // For each face
        for (var j = 0, n_faces = objects[i].faces.length; j < n_faces; ++j) {
          // Current face
          var face = objects[i].faces[j];

          // Draw the first vertex
          var P = project(face[0]);
          // console.log(`x: ${face[0].x}, y: ${face[0].y},   z: ${face[0].z}`)

          ctx.beginPath();

          // 在得到3D世界的坐标转为2D坐标的时候 需要注意3D世界坐标越往上, y 越大
          // 但是canvas 中, 2D的坐标原点在左上角 所以要写为 -P.y
          ctx.moveTo(P.x + dx, -P.y + dy);
          console.log(P.x + dx, -P.y + dy)
          // Draw the other vertices
          for (var k = 1, n_vertices = face.length; k < n_vertices; ++k) {
            P = project(face[k]);
            ctx.lineTo(P.x + dx, -P.y + dy);
            console.log(P.x + dx, -P.y + dy)

          }

          // Close the path and draw the face
          ctx.closePath();
          ctx.stroke();
          ctx.fill();
        }
      }
    }

    (function () {
      // Fix the canvas width and height
      var canvas = document.getElementById('cnv');
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      var dx = canvas.width / 2;
      var dy = canvas.height / 2;

      // Objects style
      var ctx = canvas.getContext('2d');
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillStyle = 'rgba(0, 150, 255, 0.3)';

      // Create the cube
      var cube_center = new Vertex(0, 0, 0);
      var cube = new Cube(cube_center, dy);
      var objects = [cube];

      // First render
      render(objects, ctx, dx, dy);

      // Events
      var mousedown = false;
      var mx = 0;
      var my = 0;

      canvas.addEventListener('mousedown', initMove);
      document.addEventListener('mousemove', move);
      document.addEventListener('mouseup', stopMove);

      // Rotate a vertice
      function rotate(M, center, theta, phi) {
        // theta 是角度对应的的一半弧度
        // phi 因为是角度对应弧度

        // Rotation matrix coefficients
        // theta = 0
        var ct = Math.cos(theta);
        var st = Math.sin(theta);
        // theta 是控制在 z 轴上的旋转 (因为我强制phi = 0 后发现是这样的)
        // 和预期不符合 我希望theta 应该是控制 y 轴方向上的旋转  应该影响 z x

        // phi = 0
        // phi 是绕 x 轴方向旋转的 这是在我强制 theta = 0 之后发现的
        // 影响 y z
        var cp = Math.cos(phi);
        var sp = Math.sin(phi);


        // Rotation
        var x = M.x - center.x;
        var y = M.y - center.y;
        var z = M.z - center.z;


        // 这是原来的写法  (原先codepen 这个例子 z 表示纵轴  和常识不符)
        // 以下是根据先 绕 X 轴旋转, 再绕 Z 轴旋转得到 (右手坐标系)
        // M.x = ct * x - st * cp * y + st * sp * z + center.x;
        // M.y = st * x + ct * cp * y - ct * sp * z + center.y;
        // M.z = sp * y + cp * z + center.z;


        // 现在改好了  ct st 控制在 y 轴上的旋转  cp  sp 控制在 x 轴上的旋转
        // 下面是 先绕 x 轴旋转  后绕 Y 轴旋转得到的结果
        M.x = ct * x + st * sp * y + st * cp * z + center.x;
        M.y = cp * y - sp * z + center.y;
        M.z = -st * x + ct * sp * y + ct * cp * z + center.z;
      }

      // Initialize the movement
      function initMove(evt) {
        clearTimeout(autorotate_timeout);
        mousedown = true;
        mx = evt.clientX;
        my = evt.clientY;
      }

      function move(evt) {


        if (mousedown) {
          var theta = (evt.clientX - mx) * Math.PI / 360;
          var phi = (evt.clientY - my) * Math.PI / 180;

          for (var i = 0; i < 8; ++i)
            rotate(cube.vertices[i], cube_center, theta, phi);

          mx = evt.clientX;
          my = evt.clientY;

          render(objects, ctx, dx, dy);
        } else {
          mx = evt.clientX;
          my = evt.clientY;
          ctx.clearRect(0, 0, 50, 20)
          ctx.fillText(`${mx}, ${my}`, 10, 10);
        }
      }

      function stopMove() {
        mousedown = false;
        autorotate_timeout = setTimeout(autorotate, 2000);
      }

      function autorotate() {
        // for (var i = 0; i < 8; ++i)
        // 	rotate(cube.vertices[i], cube_center, -Math.PI / 720, Math.PI / 720);
        //   render(objects, ctx, dx, dy);
        //   autorotate_timeout = setTimeout(autorotate, 30);
      }
      autorotate_timeout = setTimeout(autorotate, 2000);
    })();


  </script>

</body>

</html>